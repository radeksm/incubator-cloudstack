#!/usr/bin/awk -f

BEGIN {
    total_number_of_lines = 0;    
}

{	
    if ( $0 ~ / ERROR / || $0 ~ / WARN / ) {
        dt    = $1;
        tme   = $2
        thr   = $5;
        class = $4;
        sub( /,[0-9][0-9][0-9]/, "", tme );
        key = dt" "tme" "thr" "class;
        txt = $0;
        ewlist[key] = txt;
        print $0;
    }

    # Exceptions
    if ( /^[a-z]+\.[a-zA-Z]+./ ){
        print $0;
        exceptions[NR] = $0
        e_class = $1; # Exception class name
        if( uniq_exceptions[e_class] == "" ){
            uniq_exceptions[e_class] = 1;
        } else {
            uniq_exceptions[e_class]++;
        }
    }

    # Exception stack trace
    if ( /^[[:space:]]at[[:space:]][a-zA-Z]/ ){
        print $0;
    }

    if(total_number_of_lines == 0){
        start_date = $1" "$2;
    }
    end_date = $1" "$2;
    total_number_of_lines++;
}

END { 
    print "\n\n - - = = SUMMARY = = - -\n"
    print "Exceptions summary all"
    for(line in exceptions){
        e = exceptions[line];
        print "  Line: "line" exceptions: "e
        nr++;
    }
    print "Exceptions in total: " nr"\nExceptions by number of occurrences:"
    for(uex in uniq_exceptions){
        print "  "uex" "uniq_exceptions[uex];
    }
    print "Toatl number of lines in log file: "total_number_of_lines
    # Below regexp are the only way to match multiple digits in current version of awk
    # syntaxt like [0-9]{4} doesn't match
    if ( end_date ~ /[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]/ &&
        start_date ~ /[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]/ )
    {
        sub( /,[0-9][0-9][0-9]/, "", start_date);
        sub( /,[0-9][0-9][0-9]/, "", end_date);
        print "Log file starts on "start_date", ends on "end_date"."
    } else {
        print "Unable to fully parse log file, either this is not a CloudStack log file or file may be corrupted."
    }
}
