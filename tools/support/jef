#!/usr/bin/awk -f
# awk version required GNU Awk 3.1.7
# this sctipt doesn work with mawk on Debian

BEGIN {
    start_time=systime();
    total_number_of_lines = 0;    
    # need better way of array initialization, this way creates extra empty element
    #uniq_exceptions[""] = 0;
    #exceptions[""] = 0;
    #sorted_lines[""] = 0;
}

{	
    if ( $0 ~ / ERROR / || $0 ~ / WARN / ) {
        dt    = $1;
        tme   = $2
        thr   = $5;
        class = $4;
        sub( /,[0-9][0-9][0-9]/, "", tme );
        key = dt" "tme" "thr" "class;
        txt = $0;
        ewlist[key] = txt;
        print $0;
    }

    # Exceptions
    if ( /^[a-z]+\.[a-zA-Z]+./ ){
        print $0;
        exceptions[NR] = $0
        e_class = $1; # Exception class name
        if( uniq_exceptions[e_class] == "" ){
            uniq_exceptions[e_class] = 1;
        } else {
            uniq_exceptions[e_class]++;
        }
    }

    # Exception stack trace
    if ( /^[[:space:]]at[[:space:]][a-z]/ ){
        print $0;
    }

    if(total_number_of_lines == 0){
        start_date = $1" "$2;
    }
    end_date = $1" "$2;
    total_number_of_lines++;
}

END { 
    print "\n\n [ - - = = SUMMARY = = - - ]\n"
    print "Exceptions summary all"

    rand1=int(rand()*100 + 0.5);
    rand2=int(rand()*100 + 0.5)*10;
    rand3=int(rand()*100 + 0.5)*100;
    tmp_file = "/tmp/."rand1""rand2""rand3
    for(line in exceptions){
        e = exceptions[line];
        print("  Line: "line" exceptions: "e) > tmp_file
        nr++;
    }
    # I use sort command instead implementing own list sort function
    system("sort -n  -k 2 "tmp_file);
    print "Exceptions in total: " nr"\nExceptions by number of occurrences:"
    for(uex in uniq_exceptions){
        print ("  "uex" "uniq_exceptions[uex]);
    }
    print "Toatl number of lines in log file: "total_number_of_lines
    # Below regexp are the only way to match multiple digits in current version of awk
    # syntaxt like [0-9]{4} doesn't match
    if ( end_date ~ /[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]/ &&
        start_date ~ /[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]/ )
    {
        sub( /,[0-9][0-9][0-9]/, "", start_date);
        sub( /,[0-9][0-9][0-9]/, "", end_date);
        print "Log file starts on "start_date", ends on "end_date"."
    } else {
        print "Unable to fully parse log file, either this is not a CloudStack log file or file may be corrupted."
    }
    end_time=systime();
    time_to_compleate = end_time - start_time;
    print "Time to compleate: "time_to_compleate
}
